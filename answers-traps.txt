1.Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?
通过之前的阅读可知，调用函数时的参数传递使用寄存器 a1, a2 等通用寄存器。
阅读 call.asm 文件的第 45 行。
通过阅读 call.asm 文件中的 main 函数可知，调用 printf 函数时，13 被寄存器 a2 保存。
答案就是：a1, a2, a3 等通用寄存器；13 被寄存器 a2 保存。
2.Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)
通过阅读函数 f 和 g 得知：函数 f 调用函数 g ；函数 g 使传入的参数加 3 后返回。因此，所以总结来说，函数 f 就是使传入的参数加 3 后返回。考虑到编译器会进行内联优化，这就意味着一些显而易见的，编译时可以计算的数据会在编译时得出结果，而不是进行函数调用。查看 main 函数可以发现，printf 中包含了一个对 f 的调用。
但是对应的会汇编代码却是直接将 f(8)+1 替换为 12 。这就说明编译器对这个函数调用进行了优化，所以对于 main 函数的汇编代码来说，其并没有调用函数 f 和 g ，而是在运行之前由编译器对其进行了计算。

答案：main 的汇编代码没有调用 f 和 g 函数。编译器对其进行了优化。
3.At what address is the function printf located?
通过搜索可得到printf函数的位置0x65a。
4.What value is in the register ra just after the jalr to printf in main?
auipc 和 jalr 的配合，可以跳转到任意 32 位的地址。
具体相关命令介绍请看参考链接：reference1, RISC-V unprivileged instructions.
第 49 行，使用 auipc ra,0x0 将当前程序计数器 pc 的值存入 ra 中。第 50 行，jalr 1554(ra) 跳转到偏移地址 printf 处，也就是 0x642 的位置。
根据 reference1 中的信息，在执行完这句命令之后， 寄存器 ra 的值设置为 pc + 4 ，也就是 return address 返回地址 0x38。
答案就是：jalr 指令执行完毕之后，ra 的值为 0x38.答案就是：`jalr` 指令执行完后，`ra` 的值为 `0x38`。
5.Run the following code.

	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);
      
What is the output? Here's an ASCII table that maps bytes to characters.
The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?
请查看在线 C Compiler 的运行结果 c++ sell，它打印出了 He110 World。
首先，57616 转换为 16 进制为 e110，所以格式化描述符 %x 打印出了它的 16 进制值。其次，如果在小端（little-endian）处理器中，数据0x00646c72 的高字节存储在内存的高位，那么从内存低位，也就是低字节开始读取，对应的 ASCII 字符为 rld。如果在 大端（big-endian）处理器中，数据 0x00646c72 的高字节存储在内存的低位，那么从内存低位，也就是高字节开始读取其 ASCII 码为 dlr。
所以如果大端序和小端序输出相同的内容 i ，那么在其为大端序的时候，i 的值应该为 0x726c64，这样才能保证从内存低位读取时的输出为 rld 。
无论 57616 在大端序还是小端序，它的二进制值都为 e110 。大端序和小端序只是改变了多字节数据在内存中的存放方式，并不改变其真正的值的大小，所以 57616 始终打印为二进制 e110 。
答案就是：如果在大端序，i 的值应该为 0x00646c72 才能保证与小端序输出的内容相同。不用该变 57616 的值。
6.In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?

	printf("x=%d y=%d", 3);
根据之前的章节可知，函数参数通过寄存器`a1`、`a2`等传递。如果调用`printf`时少传递一个参数，它仍然会从相应的寄存器读取所需的参数值。由于未给定该参数，寄存器中将没有相应的值，因此函数将从寄存器中获取一个随机的、不确定的值作为参数。因此，在这种情况下，y=后面的值无法确定，是一个垃圾值。
答案就是：y=后的值是不确定的垃圾值。
